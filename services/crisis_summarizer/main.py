import os
from fastapi import FastAPI, HTTPException
from fastapi.responses import PlainTextResponse  # <--- 1. IMPORT THIS
from pydantic import BaseModel, Field
from typing import List
import vertexai
from vertexai.generative_models import GenerativeModel, Part
from google.api_core.exceptions import ResourceExhausted
from google.cloud import firestore, storage

# --- Configuration ---
# Initialize Vertex AI SDK
PROJECT_ID = os.environ.get("GCP_PROJECT", "crisisconnect-477515")
LOCATION = os.environ.get("GCP_REGION", "us-central1")
vertexai.init(project=PROJECT_ID, location=LOCATION)

# Define primary and fallback models for easy configuration
PRIMARY_MODEL = "gemini-2.5-pro"
FALLBACK_MODEL = "gemini-1.5-flash-001"

# --- Pydantic Models ---
class IncidentReport(BaseModel):
    """Data model for a single incident report."""
    location: str = Field(..., example="Boulder, CO")
    type: str = Field(..., example="Flood")
    severity: int = Field(..., ge=1, le=5, example=4)
    status: str = Field(..., example="Active")
    needs: str = Field(..., example="Rescue boats, food, blankets")

class SummarizeRequest(BaseModel):
    """Data model for the summarize request."""
    reports: List[IncidentReport]

# --- FastAPI Application ---
app = FastAPI(
    title="CrisisSummarizer Microservice",
    description="Summarizes incident reports using Gemini models with a fallback mechanism.",
    version="1.1.0",
)

# 2. USE PlainTextResponse IN THE DECORATOR
@app.post("/summarize", response_class=PlainTextResponse)
async def summarize_incidents(request: SummarizeRequest):
    """
    Accepts a list of incident reports and returns a Markdown summary.
    If the primary model (Gemini 2.5 Pro) quota is exhausted, it falls back
    to the Gemini 1.5 Flash model.
    """
    if not request.reports:
        raise HTTPException(status_code=400, detail="No incident reports provided.")

    reports_data = [report.model_dump() for report in request.reports]

    prompt = f"""
    You are a crisis management assistant. Your task is to summarize a list of incident reports into a concise, easy-to-read Markdown format.

    **Incident Reports:**
    {reports_data}

    **Instructions:**
    1.  Create a Markdown table summarizing the incidents by type. The table should include the count of incidents for each type and the average severity.
    2.  Provide a brief "Overall sentiment" (e.g., Critical, High, Medium, Low).
    3.  Write a short narrative summarizing the key needs and priorities.
    4.  The output must be in Markdown format.
    """

    try:
        # --- Attempt 1: Use the primary, more powerful model ---
        print(f"Attempting summary with primary model: {PRIMARY_MODEL}")
        model = GenerativeModel(PRIMARY_MODEL)
        response = await model.generate_content_async([Part.from_text(prompt)])
        return response.text
        
    except ResourceExhausted as e:
        # --- Attempt 2: Fallback on quota exhaustion ---
        print(f"Warning: Quota for {PRIMARY_MODEL} exhausted. Falling back to {FALLBACK_MODEL}. Error: {e}")
        try:
            fallback_model = GenerativeModel(FALLBACK_MODEL)
            response = await fallback_model.generate_content_async([Part.from_text(prompt)])
            return response.text
        except Exception as fallback_e:
            raise HTTPException(status_code=500, detail=f"Primary and fallback models failed. Fallback error: {fallback_e}")
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred with the primary model: {e}")
    

@app.get("/summarize_latest", response_class=PlainTextResponse)
async def summarize_latest():
    """
    Fetch the latest report generated by ReportWriter from GCS and summarize it.
    """
    try:
        db = firestore.Client(database="crisisconnect")
        meta_doc = db.collection("metadata").document("latest_report").get()
        if not meta_doc.exists:
            raise HTTPException(status_code=404, detail="No latest report found in Firestore.")
        
        meta = meta_doc.to_dict()
        gs_path = meta.get("report_url")
        if not gs_path or not gs_path.startswith("gs://"):
            raise HTTPException(status_code=400, detail="Invalid report_url in metadata.")

        # Parse gs://bucket/path
        _, _, bucket_name, *path_parts = gs_path.split("/")
        blob_name = "/".join(path_parts)

        storage_client = storage.Client()
        bucket = storage_client.bucket(bucket_name)
        blob = bucket.blob(blob_name)
        content = blob.download_as_text()

        prompt = f"""
        Summarize the following Markdown situation report into a short Markdown summary.
        Keep only key statistics, affected regions, and top 3 priorities.

        {content[:120000]}
        """

        model = GenerativeModel(PRIMARY_MODEL)
        response = await model.generate_content_async([Part.from_text(prompt)])
        return response.text

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to summarize latest report: {e}")


@app.get("/")
def read_root():
    """A simple endpoint to confirm the service is running."""
    return {"message": "CrisisSummarizer is running."}